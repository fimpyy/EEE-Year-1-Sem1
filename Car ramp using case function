#include <LiquidCrystal.h>
#include <Wire.h>
jhbjhhhjh
#define CLK_Encoder1 A4
#define CLK_Encoder2 A5

LiquidCrystal lcd(8, 9, 4, 5, 6, 7);

const int IN1 = 2; 
const int IN2 = 10; 
const int ENA = 3;   
const int IN3 = A2; 
const int IN4 = A3;   
const int ENB = 11; 
const int irLeft = 13;
const int irRight = 12;

const int MPU_ADDR = 0x68;

int16_t accelX, accelY, accelZ;
float accelX_scaled, accelY_scaled, accelZ_scaled;

unsigned long previousMillis = 0;
const unsigned long interval = 10;
int motorSpeed = 0;
volatile int counter_Encoder1 = 0; 
volatile int counter_Encoder2 = 0; 
int lastStateCLK_Encoder1;
int lastStateCLK_Encoder2;
unsigned long lastTime = 0;
volatile int lastCounter_Encoder1 = 0;
volatile int lastCounter_Encoder2 = 0;
float pulsesPerRevolution = 20.0;
float wheelCircumference = 20.15;
float distance_Encoder1 = 0.0;     
float distance_Encoder2 = 0.0; 
float timeInterval = 100.0; 
float avgDistance; 

unsigned long lastRampTime = 0;
const unsigned long rampInterval = 100;  
int motorSpeedA = 0;
int motorSpeedB = 0;

unsigned long stopTime = 0;
bool carStop = true;

enum CarState {
  RAMP,
  LINE_FOLLOWING,
};

CarState stateNow = RAMP;

void setup() {
  lcd.begin(16, 2);
  lcd.print("3");
  delay(500);
  lcd.clear();
  lcd.print("2");
  delay(200);
  lcd.clear();
  lcd.print("1");
  delay(300);
  lcd.clear();
  pinMode(CLK_Encoder1, INPUT);
  pinMode(CLK_Encoder2, INPUT);
  pinMode(IN1, OUTPUT);
  pinMode(IN2, OUTPUT);
  pinMode(ENA, OUTPUT);
  pinMode(IN3, OUTPUT);
  pinMode(IN4, OUTPUT);
  pinMode(ENB, OUTPUT);
  pinMode(irLeft, INPUT);
  pinMode(irRight, INPUT);

  Wire.begin();
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(0x6B);
  Wire.write(0x00);
  Wire.endTransmission();

  Serial.begin(9600);
  analogWrite(ENA, motorSpeed);
  analogWrite(ENB, motorSpeed);
  lastStateCLK_Encoder1 = digitalRead(CLK_Encoder1);
  lastStateCLK_Encoder2 = digitalRead(CLK_Encoder2);
}

void readMPU6050() {
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(0x3B);
  Wire.endTransmission(false);
  Wire.requestFrom(MPU_ADDR, 6, true);

  if (Wire.available() == 6) {
    accelX = Wire.read() << 8 | Wire.read();
    accelY = Wire.read() << 8 | Wire.read();
    accelZ = Wire.read() << 8 | Wire.read();

    accelX_scaled = accelX / 16384.0;
    accelY_scaled = accelY / 16384.0;
    accelZ_scaled = accelZ / 16384.0;
  }
}
void stopMotor(){
  motorSpeedA = 0;
  motorSpeedB = 0;
  analogWrite(ENA, motorSpeedA);
  analogWrite(ENB, motorSpeedB);
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, LOW);
}

void leftMotorFoward(){
  motorSpeedA = 90; 
  analogWrite(ENA, motorSpeedA);
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);
}

void leftMotorBackward(){
  motorSpeedA = 255; 
  analogWrite(ENA, motorSpeedA);
  digitalWrite(IN1, LOW);
  digitalWrite(IN2, HIGH);
}

void rightMotorFoward(){
  motorSpeedB = 90;
  analogWrite(ENB, motorSpeedB);
  digitalWrite(IN3, HIGH);
  digitalWrite(IN4, LOW);
}

void rightMotorBackward(){
  motorSpeedB = 255; 
  analogWrite(ENB, motorSpeedB);
  digitalWrite(IN3, LOW);
  digitalWrite(IN4, HIGH);
}

void fullSpeed(){
  motorSpeedA = 255;
  motorSpeedB = 255;
  analogWrite(ENA, motorSpeedA);
  analogWrite(ENB, motorSpeedB);
  digitalWrite(IN1, HIGH);
  digitalWrite(IN2, LOW);
  digitalWrite(IN3, HIGH);
  digitalWrite(IN4, LOW);
}

void loop() {
  unsigned long currentMillis = millis();
  static unsigned long lastPrint = 0;
  static int isLeftDetected;
  static int isRightDetected;
  const unsigned long IRresponse = 20;

  if (currentMillis - lastPrint >= IRresponse) {
    lastPrint = currentMillis;
    readMPU6050();
    isLeftDetected = digitalRead(irLeft);
    isRightDetected = digitalRead(irRight);
  }
  float tiltAngle = (atan2(accelY_scaled, accelZ_scaled) * 180 / 3.142) * -1;
  float tiltUpThreshold = 25.0;
  float tiltDownThreshold = -20.0;

  motorSpeedA = constrain(motorSpeedA, 0, 255);
  motorSpeedB = constrain(motorSpeedB, 0, 255);

  switch (stateNow) {
    case RAMP:
      motorSpeedA = 100;
      motorSpeedB = 100;
      analogWrite(ENA, motorSpeedA);
      analogWrite(ENB, motorSpeedB);
      digitalWrite(IN1, HIGH);
      digitalWrite(IN2, LOW);
      digitalWrite(IN3, HIGH);
      digitalWrite(IN4, LOW);
      if (tiltAngle > tiltUpThreshold) {
        fullSpeed();
        carStop = false;
      } else if (tiltAngle < tiltUpThreshold && !carStop) {
        stateNow = LINE_FOLLOWING;
      }
    break;

    case LINE_FOLLOWING:
      if (!isLeftDetected && !isRightDetected) {
          stopMotor();
          return;
        }

      if (isLeftDetected) {
        leftMotorFoward();
      } else {
        leftMotorBackward();
      }

      if (isRightDetected) {
        rightMotorFoward();
      } else {
        rightMotorBackward();
      }
      break;
  }
}


      
